#!/usr/bin/env perl

# special key: molecule=[na|aa]

# returns [
# { "message": "message string",
#   "keys": [key1, key2]
#},
#]

use strict;
use warnings;
use JSON::PP;
use Data::Dumper;

my $seqstat_exec = "/usr/bin/seqstat";

chomp( my $header = <> );
die("$0 expects key value pairs ['kv'], not $header") unless( $header eq 'kv' );

# if the user specifies a molecule type
my $molecule;

# holds the key value pairs. All values are assumed files
my %pairs;

while( my $arg = <> ) {
    chomp($arg);
	my ($key, $value) = split(/\s*=\s*/, $arg);
	
    if( $key eq 'molecule' ) {
        $molecule = $value;
        undef $molecule unless( $molecule eq 'aa' || $molecule eq 'na' );
        next;
    }	
    $pairs{$key} = $value;
}

my @json;
foreach my $key ( keys %pairs ) {
    my $message = &check_fasta( $pairs{$key}, $molecule );
	next unless $message;
    push(@json, { "message" => $message,"keys" => [ $key ] });
}

#print Dumper(@json);
if( @json > 0 ) {
	print encode_json(\@json);
	exit 1
}

sub check_fasta {
	my ($file, $mol) = @_;
	my $msg;
	
	my $seqstat_cmd = "$seqstat_exec $file";
	open(IN, "$seqstat_cmd |") or die("Can't run cmd $seqstat_cmd");
	while( my $line = <IN> ) {
	    if( $line =~ /Format:\s+(\S+)/ ) {
	        unless( $1 eq 'FASTA' ) {
	            $msg = "File: $file not fasta." unless( $1 eq 'FASTA' );
    	        last;
            }
	    }
	    if( defined( $mol ) && $line =~ /Type.*?(\S+)$/ ) {
	        my $type = ($1 eq 'DNA') ? 'na' : 'aa';
	        if( $type ne $mol ) {
	            $msg = "File: $file first sequence is $type, not $molecule" ;
	            last;
            }
	    }
	}
	close(IN);
	
	return $msg;
}
